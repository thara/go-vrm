// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package internal

import (
	"encoding/json"
	"fmt"
	"reflect"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonCreditNotation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonCreditNotation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonCreditNotation, v)
	}
	*j = VRMCVrmMetaSchemaJsonCreditNotation(v)
	return nil
}

type VRMCVrmMetaSchemaJson struct {
	// A flag that permits to use this model in contents contain anti-social
	// activities or hate speeches
	AllowAntisocialOrHateUsage bool `json:"allowAntisocialOrHateUsage,omitempty"`

	// A flag that permits to use this model in excessively sexual contents
	AllowExcessivelySexualUsage bool `json:"allowExcessivelySexualUsage,omitempty"`

	// A flag that permits to use this model in excessively violent contents
	AllowExcessivelyViolentUsage bool `json:"allowExcessivelyViolentUsage,omitempty"`

	// A flag that permits to use this model in political or religious contents
	AllowPoliticalOrReligiousUsage bool `json:"allowPoliticalOrReligiousUsage,omitempty"`

	// A flag that permits to redistribute this model
	AllowRedistribution bool `json:"allowRedistribution,omitempty"`

	// Authors of the model
	Authors []string `json:"authors"`

	// A person who can perform as an avatar with this model
	AvatarPermission VRMCVrmMetaSchemaJsonAvatarPermission `json:"avatarPermission,omitempty"`

	// An option that permits to use this model in commercial products
	CommercialUsage VRMCVrmMetaSchemaJsonCommercialUsage `json:"commercialUsage,omitempty"`

	// An information that describes the contact information of the author
	ContactInformation *string `json:"contactInformation,omitempty"`

	// An information that describes the copyright of the model
	CopyrightInformation *string `json:"copyrightInformation,omitempty"`

	// An option that forces or abandons to display the credit of this model
	CreditNotation VRMCVrmMetaSchemaJsonCreditNotation `json:"creditNotation,omitempty"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// A URL towards the license document this model refers to
	LicenseUrl string `json:"licenseUrl"`

	// An option that controls the condition to modify this model
	Modification VRMCVrmMetaSchemaJsonModification `json:"modification,omitempty"`

	// The name of the model
	Name string `json:"name"`

	// Describe the URL links of other license
	OtherLicenseUrl *string `json:"otherLicenseUrl,omitempty"`

	// References / original works of the model
	References []string `json:"references,omitempty"`

	// Third party licenses of the model, if required. You can use line breaks
	ThirdPartyLicenses *string `json:"thirdPartyLicenses,omitempty"`

	// The index to the thumbnail image of the model in gltf.images
	ThumbnailImage interface{} `json:"thumbnailImage,omitempty"`

	// The version of the model
	Version *string `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonAvatarPermission) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonAvatarPermission {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonAvatarPermission, v)
	}
	*j = VRMCVrmMetaSchemaJsonAvatarPermission(v)
	return nil
}

const VRMCVrmMetaSchemaJsonAvatarPermissionOnlyAuthor VRMCVrmMetaSchemaJsonAvatarPermission = "onlyAuthor"
const VRMCVrmMetaSchemaJsonAvatarPermissionOnlySeparatelyLicensedPerson VRMCVrmMetaSchemaJsonAvatarPermission = "onlySeparatelyLicensedPerson"
const VRMCVrmMetaSchemaJsonAvatarPermissionEveryone VRMCVrmMetaSchemaJsonAvatarPermission = "everyone"

type VRMCVrmMetaSchemaJsonCommercialUsage string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonModification) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonModification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonModification, v)
	}
	*j = VRMCVrmMetaSchemaJsonModification(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonCommercialUsage) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonCommercialUsage {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonCommercialUsage, v)
	}
	*j = VRMCVrmMetaSchemaJsonCommercialUsage(v)
	return nil
}

const VRMCVrmMetaSchemaJsonCommercialUsagePersonalNonProfit VRMCVrmMetaSchemaJsonCommercialUsage = "personalNonProfit"
const VRMCVrmMetaSchemaJsonCommercialUsagePersonalProfit VRMCVrmMetaSchemaJsonCommercialUsage = "personalProfit"
const VRMCVrmMetaSchemaJsonCommercialUsageCorporation VRMCVrmMetaSchemaJsonCommercialUsage = "corporation"

type VRMCVrmMetaSchemaJsonAvatarPermission string

type VRMCVrmMetaSchemaJsonCreditNotation string

const VRMCVrmMetaSchemaJsonCreditNotationRequired VRMCVrmMetaSchemaJsonCreditNotation = "required"
const VRMCVrmMetaSchemaJsonCreditNotationUnnecessary VRMCVrmMetaSchemaJsonCreditNotation = "unnecessary"

type VRMCVrmMetaSchemaJsonModification string

const VRMCVrmMetaSchemaJsonModificationAllowModification VRMCVrmMetaSchemaJsonModification = "allowModification"
const VRMCVrmMetaSchemaJsonModificationAllowModificationRedistribution VRMCVrmMetaSchemaJsonModification = "allowModificationRedistribution"
const VRMCVrmMetaSchemaJsonModificationProhibited VRMCVrmMetaSchemaJsonModification = "prohibited"

var enumValues_VRMCVrmMetaSchemaJsonAvatarPermission = []interface{}{
	"onlyAuthor",
	"onlySeparatelyLicensedPerson",
	"everyone",
}
var enumValues_VRMCVrmMetaSchemaJsonCommercialUsage = []interface{}{
	"personalNonProfit",
	"personalProfit",
	"corporation",
}
var enumValues_VRMCVrmMetaSchemaJsonCreditNotation = []interface{}{
	"required",
	"unnecessary",
}
var enumValues_VRMCVrmMetaSchemaJsonModification = []interface{}{
	"prohibited",
	"allowModification",
	"allowModificationRedistribution",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["authors"]; !ok || v == nil {
		return fmt.Errorf("field authors: required")
	}
	if v, ok := raw["licenseUrl"]; !ok || v == nil {
		return fmt.Errorf("field licenseUrl: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain VRMCVrmMetaSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["allowAntisocialOrHateUsage"]; !ok || v == nil {
		plain.AllowAntisocialOrHateUsage = false
	}
	if v, ok := raw["allowExcessivelySexualUsage"]; !ok || v == nil {
		plain.AllowExcessivelySexualUsage = false
	}
	if v, ok := raw["allowExcessivelyViolentUsage"]; !ok || v == nil {
		plain.AllowExcessivelyViolentUsage = false
	}
	if v, ok := raw["allowPoliticalOrReligiousUsage"]; !ok || v == nil {
		plain.AllowPoliticalOrReligiousUsage = false
	}
	if v, ok := raw["allowRedistribution"]; !ok || v == nil {
		plain.AllowRedistribution = false
	}
	if v, ok := raw["avatarPermission"]; !ok || v == nil {
		plain.AvatarPermission = "onlyAuthor"
	}
	if v, ok := raw["commercialUsage"]; !ok || v == nil {
		plain.CommercialUsage = "personalNonProfit"
	}
	if v, ok := raw["creditNotation"]; !ok || v == nil {
		plain.CreditNotation = "required"
	}
	if v, ok := raw["modification"]; !ok || v == nil {
		plain.Modification = "prohibited"
	}
	*j = VRMCVrmMetaSchemaJson(plain)
	return nil
}
