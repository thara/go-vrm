// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package internal

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node: required")
	}
	type Plain VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["authors"]; !ok || v == nil {
		return fmt.Errorf("field authors: required")
	}
	if v, ok := raw["licenseUrl"]; !ok || v == nil {
		return fmt.Errorf("field licenseUrl: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain VRMCVrmMetaSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["allowAntisocialOrHateUsage"]; !ok || v == nil {
		plain.AllowAntisocialOrHateUsage = false
	}
	if v, ok := raw["allowExcessivelySexualUsage"]; !ok || v == nil {
		plain.AllowExcessivelySexualUsage = false
	}
	if v, ok := raw["allowExcessivelyViolentUsage"]; !ok || v == nil {
		plain.AllowExcessivelyViolentUsage = false
	}
	if v, ok := raw["allowPoliticalOrReligiousUsage"]; !ok || v == nil {
		plain.AllowPoliticalOrReligiousUsage = false
	}
	if v, ok := raw["allowRedistribution"]; !ok || v == nil {
		plain.AllowRedistribution = false
	}
	if v, ok := raw["avatarPermission"]; !ok || v == nil {
		plain.AvatarPermission = "onlyAuthor"
	}
	if v, ok := raw["commercialUsage"]; !ok || v == nil {
		plain.CommercialUsage = "personalNonProfit"
	}
	if v, ok := raw["creditNotation"]; !ok || v == nil {
		plain.CreditNotation = "required"
	}
	if v, ok := raw["modification"]; !ok || v == nil {
		plain.Modification = "prohibited"
	}
	*j = VRMCVrmMetaSchemaJson(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType, v)
	}
	*j = VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType(v)
	return nil
}

const VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonTypeColor VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType = "color"
const VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonTypeEmissionColor VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType = "emissionColor"
const VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonTypeShadeColor VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType = "shadeColor"
const VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonTypeMatcapColor VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType = "matcapColor"
const VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonTypeRimColor VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType = "rimColor"
const VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonTypeOutlineColor VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType = "outlineColor"

// Material color value associated with a expression
type VRMCVrmExpressionsExpressionMaterialColorBindSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// target material
	Material interface{} `json:"material"`

	// target color
	TargetValue []float64 `json:"targetValue"`

	// Type corresponds to the JSON schema field "type".
	Type VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionMaterialColorBindSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["material"]; !ok || v == nil {
		return fmt.Errorf("field material: required")
	}
	if v, ok := raw["targetValue"]; !ok || v == nil {
		return fmt.Errorf("field targetValue: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain VRMCVrmExpressionsExpressionMaterialColorBindSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCVrmExpressionsExpressionMaterialColorBindSchemaJson(plain)
	return nil
}

type VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionMorphTargetBindSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index: required")
	}
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node: required")
	}
	if v, ok := raw["weight"]; !ok || v == nil {
		return fmt.Errorf("field weight: required")
	}
	type Plain VRMCVrmExpressionsExpressionMorphTargetBindSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCVrmExpressionsExpressionMorphTargetBindSchemaJson(plain)
	return nil
}

type VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonModification) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonModification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonModification, v)
	}
	*j = VRMCVrmMetaSchemaJsonModification(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink, v)
	}
	*j = VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink(v)
	return nil
}

const VRMCVrmExpressionsExpressionSchemaJsonOverrideBlinkNone VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink = "none"
const VRMCVrmExpressionsExpressionSchemaJsonOverrideBlinkBlock VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink = "block"
const VRMCVrmExpressionsExpressionSchemaJsonOverrideBlinkBlend VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink = "blend"

type VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonCreditNotation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonCreditNotation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonCreditNotation, v)
	}
	*j = VRMCVrmMetaSchemaJsonCreditNotation(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt, v)
	}
	*j = VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt(v)
	return nil
}

const VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAtNone VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt = "none"
const VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAtBlock VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt = "block"
const VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAtBlend VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt = "blend"

type VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonCommercialUsage) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonCommercialUsage {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonCommercialUsage, v)
	}
	*j = VRMCVrmMetaSchemaJsonCommercialUsage(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth, v)
	}
	*j = VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth(v)
	return nil
}

const VRMCVrmExpressionsExpressionSchemaJsonOverrideMouthNone VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth = "none"
const VRMCVrmExpressionsExpressionSchemaJsonOverrideMouthBlock VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth = "block"
const VRMCVrmExpressionsExpressionSchemaJsonOverrideMouthBlend VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth = "blend"

// Texture transform value associated with a expression
type VRMCVrmExpressionsExpressionTextureTransformBindSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// target material
	Material interface{} `json:"material"`

	// uv offset for TEXCOORD_0
	Offset []float64 `json:"offset,omitempty"`

	// uv scaling for TEXCOORD_0
	Scale []float64 `json:"scale,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionTextureTransformBindSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["material"]; !ok || v == nil {
		return fmt.Errorf("field material: required")
	}
	type Plain VRMCVrmExpressionsExpressionTextureTransformBindSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["offset"]; !ok || v == nil {
		plain.Offset = []interface{}{
			0,
			0,
		}
	}
	if v, ok := raw["scale"]; !ok || v == nil {
		plain.Scale = []interface{}{
			1,
			1,
		}
	}
	*j = VRMCVrmExpressionsExpressionTextureTransformBindSchemaJson(plain)
	return nil
}

// Definition of expression by weighted animation
type VRMCVrmExpressionsExpressionSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// A value greater than 0.5 is 1.0, otherwise 0.0
	IsBinary bool `json:"isBinary,omitempty"`

	// Material color animation references
	MaterialColorBinds []VRMCVrmExpressionsExpressionMaterialColorBindSchemaJson `json:"materialColorBinds,omitempty"`

	// Specify a morph target
	MorphTargetBinds []VRMCVrmExpressionsExpressionMorphTargetBindSchemaJson `json:"morphTargetBinds,omitempty"`

	// Override values of Blink expressions when this Expression is enabled
	OverrideBlink VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink `json:"overrideBlink,omitempty"`

	// Override values of LookAt expressions when this Expression is enabled
	OverrideLookAt VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt `json:"overrideLookAt,omitempty"`

	// Override values of Mouth expressions when this Expression is enabled
	OverrideMouth VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth `json:"overrideMouth,omitempty"`

	// Texture transform animation references
	TextureTransformBinds []VRMCVrmExpressionsExpressionTextureTransformBindSchemaJson `json:"textureTransformBinds,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmExpressionsExpressionSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VRMCVrmExpressionsExpressionSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["isBinary"]; !ok || v == nil {
		plain.IsBinary = false
	}
	if v, ok := raw["overrideBlink"]; !ok || v == nil {
		plain.OverrideBlink = "none"
	}
	if v, ok := raw["overrideLookAt"]; !ok || v == nil {
		plain.OverrideLookAt = "none"
	}
	if v, ok := raw["overrideMouth"]; !ok || v == nil {
		plain.OverrideMouth = "none"
	}
	*j = VRMCVrmExpressionsExpressionSchemaJson(plain)
	return nil
}

// Custom expressions
type VRMCVrmExpressionsSchemaJsonCustom map[string]VRMCVrmExpressionsExpressionSchemaJson

// Preset expressions
type VRMCVrmExpressionsSchemaJsonPreset struct {
	// Aa corresponds to the JSON schema field "aa".
	Aa *VRMCVrmExpressionsExpressionSchemaJson `json:"aa,omitempty"`

	// Angry corresponds to the JSON schema field "angry".
	Angry *VRMCVrmExpressionsExpressionSchemaJson `json:"angry,omitempty"`

	// Blink corresponds to the JSON schema field "blink".
	Blink *VRMCVrmExpressionsExpressionSchemaJson `json:"blink,omitempty"`

	// BlinkLeft corresponds to the JSON schema field "blinkLeft".
	BlinkLeft *VRMCVrmExpressionsExpressionSchemaJson `json:"blinkLeft,omitempty"`

	// BlinkRight corresponds to the JSON schema field "blinkRight".
	BlinkRight *VRMCVrmExpressionsExpressionSchemaJson `json:"blinkRight,omitempty"`

	// Ee corresponds to the JSON schema field "ee".
	Ee *VRMCVrmExpressionsExpressionSchemaJson `json:"ee,omitempty"`

	// Happy corresponds to the JSON schema field "happy".
	Happy *VRMCVrmExpressionsExpressionSchemaJson `json:"happy,omitempty"`

	// Ih corresponds to the JSON schema field "ih".
	Ih *VRMCVrmExpressionsExpressionSchemaJson `json:"ih,omitempty"`

	// LookDown corresponds to the JSON schema field "lookDown".
	LookDown *VRMCVrmExpressionsExpressionSchemaJson `json:"lookDown,omitempty"`

	// LookLeft corresponds to the JSON schema field "lookLeft".
	LookLeft *VRMCVrmExpressionsExpressionSchemaJson `json:"lookLeft,omitempty"`

	// LookRight corresponds to the JSON schema field "lookRight".
	LookRight *VRMCVrmExpressionsExpressionSchemaJson `json:"lookRight,omitempty"`

	// LookUp corresponds to the JSON schema field "lookUp".
	LookUp *VRMCVrmExpressionsExpressionSchemaJson `json:"lookUp,omitempty"`

	// Neutral corresponds to the JSON schema field "neutral".
	Neutral *VRMCVrmExpressionsExpressionSchemaJson `json:"neutral,omitempty"`

	// Oh corresponds to the JSON schema field "oh".
	Oh *VRMCVrmExpressionsExpressionSchemaJson `json:"oh,omitempty"`

	// Ou corresponds to the JSON schema field "ou".
	Ou *VRMCVrmExpressionsExpressionSchemaJson `json:"ou,omitempty"`

	// Relaxed corresponds to the JSON schema field "relaxed".
	Relaxed *VRMCVrmExpressionsExpressionSchemaJson `json:"relaxed,omitempty"`

	// Sad corresponds to the JSON schema field "sad".
	Sad *VRMCVrmExpressionsExpressionSchemaJson `json:"sad,omitempty"`

	// Surprised corresponds to the JSON schema field "surprised".
	Surprised *VRMCVrmExpressionsExpressionSchemaJson `json:"surprised,omitempty"`
}

// Definition of expressions
type VRMCVrmExpressionsSchemaJson struct {
	// Custom expressions
	Custom VRMCVrmExpressionsSchemaJsonCustom `json:"custom,omitempty"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// Preset expressions
	Preset *VRMCVrmExpressionsSchemaJsonPreset `json:"preset,omitempty"`
}

type VRMCVrmFirstPersonMeshAnnotationSchemaJsonType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmMetaSchemaJsonAvatarPermission) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmMetaSchemaJsonAvatarPermission {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmMetaSchemaJsonAvatarPermission, v)
	}
	*j = VRMCVrmMetaSchemaJsonAvatarPermission(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmFirstPersonMeshAnnotationSchemaJsonType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmFirstPersonMeshAnnotationSchemaJsonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmFirstPersonMeshAnnotationSchemaJsonType, v)
	}
	*j = VRMCVrmFirstPersonMeshAnnotationSchemaJsonType(v)
	return nil
}

const VRMCVrmFirstPersonMeshAnnotationSchemaJsonTypeAuto VRMCVrmFirstPersonMeshAnnotationSchemaJsonType = "auto"
const VRMCVrmFirstPersonMeshAnnotationSchemaJsonTypeBoth VRMCVrmFirstPersonMeshAnnotationSchemaJsonType = "both"

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmLookAtSchemaJsonType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VRMCVrmLookAtSchemaJsonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VRMCVrmLookAtSchemaJsonType, v)
	}
	*j = VRMCVrmLookAtSchemaJsonType(v)
	return nil
}

// Morph target value associated with a expression
type VRMCVrmExpressionsExpressionMorphTargetBindSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// The index of the morph target in the mesh.
	Index interface{} `json:"index"`

	// The index of the node that attached to target mesh.
	Node interface{} `json:"node"`

	// The weight value of target morph target.
	Weight float64 `json:"weight"`
}

// Specify how the mesh should be interpreted by the camera
type VRMCVrmFirstPersonMeshAnnotationSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// The index of the node that attached to target mesh.
	Node interface{} `json:"node"`

	// How the camera interprets the mesh.
	Type VRMCVrmFirstPersonMeshAnnotationSchemaJsonType `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmFirstPersonMeshAnnotationSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain VRMCVrmFirstPersonMeshAnnotationSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCVrmFirstPersonMeshAnnotationSchemaJson(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmHumanoidSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["humanBones"]; !ok || v == nil {
		return fmt.Errorf("field humanBones: required")
	}
	type Plain VRMCVrmHumanoidSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCVrmHumanoidSchemaJson(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmHumanoidHumanBonesSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["head"]; !ok || v == nil {
		return fmt.Errorf("field head: required")
	}
	if v, ok := raw["hips"]; !ok || v == nil {
		return fmt.Errorf("field hips: required")
	}
	if v, ok := raw["leftFoot"]; !ok || v == nil {
		return fmt.Errorf("field leftFoot: required")
	}
	if v, ok := raw["leftHand"]; !ok || v == nil {
		return fmt.Errorf("field leftHand: required")
	}
	if v, ok := raw["leftLowerArm"]; !ok || v == nil {
		return fmt.Errorf("field leftLowerArm: required")
	}
	if v, ok := raw["leftLowerLeg"]; !ok || v == nil {
		return fmt.Errorf("field leftLowerLeg: required")
	}
	if v, ok := raw["leftUpperArm"]; !ok || v == nil {
		return fmt.Errorf("field leftUpperArm: required")
	}
	if v, ok := raw["leftUpperLeg"]; !ok || v == nil {
		return fmt.Errorf("field leftUpperLeg: required")
	}
	if v, ok := raw["rightFoot"]; !ok || v == nil {
		return fmt.Errorf("field rightFoot: required")
	}
	if v, ok := raw["rightHand"]; !ok || v == nil {
		return fmt.Errorf("field rightHand: required")
	}
	if v, ok := raw["rightLowerArm"]; !ok || v == nil {
		return fmt.Errorf("field rightLowerArm: required")
	}
	if v, ok := raw["rightLowerLeg"]; !ok || v == nil {
		return fmt.Errorf("field rightLowerLeg: required")
	}
	if v, ok := raw["rightUpperArm"]; !ok || v == nil {
		return fmt.Errorf("field rightUpperArm: required")
	}
	if v, ok := raw["rightUpperLeg"]; !ok || v == nil {
		return fmt.Errorf("field rightUpperLeg: required")
	}
	if v, ok := raw["spine"]; !ok || v == nil {
		return fmt.Errorf("field spine: required")
	}
	type Plain VRMCVrmHumanoidHumanBonesSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCVrmHumanoidHumanBonesSchemaJson(plain)
	return nil
}

const VRMCVrmFirstPersonMeshAnnotationSchemaJsonTypeFirstPersonOnly VRMCVrmFirstPersonMeshAnnotationSchemaJsonType = "firstPersonOnly"
const VRMCVrmFirstPersonMeshAnnotationSchemaJsonTypeThirdPersonOnly VRMCVrmFirstPersonMeshAnnotationSchemaJsonType = "thirdPersonOnly"

// First-person perspective settings
type VRMCVrmFirstPersonSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// Mesh rendering annotation for cameras.
	MeshAnnotations []VRMCVrmFirstPersonMeshAnnotationSchemaJson `json:"meshAnnotations,omitempty"`
}

// Represents a single bone of a Humanoid.
type VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// Represents a single glTF node tied to this humanBone.
	Node interface{} `json:"node"`
}

// Represents a set of humanBones of a humanoid.
type VRMCVrmHumanoidHumanBonesSchemaJson struct {
	// Chest corresponds to the JSON schema field "chest".
	Chest *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"chest,omitempty"`

	// Head corresponds to the JSON schema field "head".
	Head VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"head"`

	// Hips corresponds to the JSON schema field "hips".
	Hips VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"hips"`

	// Jaw corresponds to the JSON schema field "jaw".
	Jaw *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"jaw,omitempty"`

	// LeftEye corresponds to the JSON schema field "leftEye".
	LeftEye *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftEye,omitempty"`

	// LeftFoot corresponds to the JSON schema field "leftFoot".
	LeftFoot VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftFoot"`

	// LeftHand corresponds to the JSON schema field "leftHand".
	LeftHand VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftHand"`

	// LeftIndexDistal corresponds to the JSON schema field "leftIndexDistal".
	LeftIndexDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftIndexDistal,omitempty"`

	// LeftIndexIntermediate corresponds to the JSON schema field
	// "leftIndexIntermediate".
	LeftIndexIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftIndexIntermediate,omitempty"`

	// LeftIndexProximal corresponds to the JSON schema field "leftIndexProximal".
	LeftIndexProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftIndexProximal,omitempty"`

	// LeftLittleDistal corresponds to the JSON schema field "leftLittleDistal".
	LeftLittleDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftLittleDistal,omitempty"`

	// LeftLittleIntermediate corresponds to the JSON schema field
	// "leftLittleIntermediate".
	LeftLittleIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftLittleIntermediate,omitempty"`

	// LeftLittleProximal corresponds to the JSON schema field "leftLittleProximal".
	LeftLittleProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftLittleProximal,omitempty"`

	// LeftLowerArm corresponds to the JSON schema field "leftLowerArm".
	LeftLowerArm VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftLowerArm"`

	// LeftLowerLeg corresponds to the JSON schema field "leftLowerLeg".
	LeftLowerLeg VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftLowerLeg"`

	// LeftMiddleDistal corresponds to the JSON schema field "leftMiddleDistal".
	LeftMiddleDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftMiddleDistal,omitempty"`

	// LeftMiddleIntermediate corresponds to the JSON schema field
	// "leftMiddleIntermediate".
	LeftMiddleIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftMiddleIntermediate,omitempty"`

	// LeftMiddleProximal corresponds to the JSON schema field "leftMiddleProximal".
	LeftMiddleProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftMiddleProximal,omitempty"`

	// LeftRingDistal corresponds to the JSON schema field "leftRingDistal".
	LeftRingDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftRingDistal,omitempty"`

	// LeftRingIntermediate corresponds to the JSON schema field
	// "leftRingIntermediate".
	LeftRingIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftRingIntermediate,omitempty"`

	// LeftRingProximal corresponds to the JSON schema field "leftRingProximal".
	LeftRingProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftRingProximal,omitempty"`

	// LeftShoulder corresponds to the JSON schema field "leftShoulder".
	LeftShoulder *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftShoulder,omitempty"`

	// LeftThumbDistal corresponds to the JSON schema field "leftThumbDistal".
	LeftThumbDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftThumbDistal,omitempty"`

	// LeftThumbMetacarpal corresponds to the JSON schema field "leftThumbMetacarpal".
	LeftThumbMetacarpal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftThumbMetacarpal,omitempty"`

	// LeftThumbProximal corresponds to the JSON schema field "leftThumbProximal".
	LeftThumbProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftThumbProximal,omitempty"`

	// LeftToes corresponds to the JSON schema field "leftToes".
	LeftToes *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftToes,omitempty"`

	// LeftUpperArm corresponds to the JSON schema field "leftUpperArm".
	LeftUpperArm VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftUpperArm"`

	// LeftUpperLeg corresponds to the JSON schema field "leftUpperLeg".
	LeftUpperLeg VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"leftUpperLeg"`

	// Neck corresponds to the JSON schema field "neck".
	Neck *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"neck,omitempty"`

	// RightEye corresponds to the JSON schema field "rightEye".
	RightEye *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightEye,omitempty"`

	// RightFoot corresponds to the JSON schema field "rightFoot".
	RightFoot VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightFoot"`

	// RightHand corresponds to the JSON schema field "rightHand".
	RightHand VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightHand"`

	// RightIndexDistal corresponds to the JSON schema field "rightIndexDistal".
	RightIndexDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightIndexDistal,omitempty"`

	// RightIndexIntermediate corresponds to the JSON schema field
	// "rightIndexIntermediate".
	RightIndexIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightIndexIntermediate,omitempty"`

	// RightIndexProximal corresponds to the JSON schema field "rightIndexProximal".
	RightIndexProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightIndexProximal,omitempty"`

	// RightLittleDistal corresponds to the JSON schema field "rightLittleDistal".
	RightLittleDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightLittleDistal,omitempty"`

	// RightLittleIntermediate corresponds to the JSON schema field
	// "rightLittleIntermediate".
	RightLittleIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightLittleIntermediate,omitempty"`

	// RightLittleProximal corresponds to the JSON schema field "rightLittleProximal".
	RightLittleProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightLittleProximal,omitempty"`

	// RightLowerArm corresponds to the JSON schema field "rightLowerArm".
	RightLowerArm VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightLowerArm"`

	// RightLowerLeg corresponds to the JSON schema field "rightLowerLeg".
	RightLowerLeg VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightLowerLeg"`

	// RightMiddleDistal corresponds to the JSON schema field "rightMiddleDistal".
	RightMiddleDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightMiddleDistal,omitempty"`

	// RightMiddleIntermediate corresponds to the JSON schema field
	// "rightMiddleIntermediate".
	RightMiddleIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightMiddleIntermediate,omitempty"`

	// RightMiddleProximal corresponds to the JSON schema field "rightMiddleProximal".
	RightMiddleProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightMiddleProximal,omitempty"`

	// RightRingDistal corresponds to the JSON schema field "rightRingDistal".
	RightRingDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightRingDistal,omitempty"`

	// RightRingIntermediate corresponds to the JSON schema field
	// "rightRingIntermediate".
	RightRingIntermediate *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightRingIntermediate,omitempty"`

	// RightRingProximal corresponds to the JSON schema field "rightRingProximal".
	RightRingProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightRingProximal,omitempty"`

	// RightShoulder corresponds to the JSON schema field "rightShoulder".
	RightShoulder *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightShoulder,omitempty"`

	// RightThumbDistal corresponds to the JSON schema field "rightThumbDistal".
	RightThumbDistal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightThumbDistal,omitempty"`

	// RightThumbMetacarpal corresponds to the JSON schema field
	// "rightThumbMetacarpal".
	RightThumbMetacarpal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightThumbMetacarpal,omitempty"`

	// RightThumbProximal corresponds to the JSON schema field "rightThumbProximal".
	RightThumbProximal *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightThumbProximal,omitempty"`

	// RightToes corresponds to the JSON schema field "rightToes".
	RightToes *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightToes,omitempty"`

	// RightUpperArm corresponds to the JSON schema field "rightUpperArm".
	RightUpperArm VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightUpperArm"`

	// RightUpperLeg corresponds to the JSON schema field "rightUpperLeg".
	RightUpperLeg VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"rightUpperLeg"`

	// Spine corresponds to the JSON schema field "spine".
	Spine VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"spine"`

	// UpperChest corresponds to the JSON schema field "upperChest".
	UpperChest *VRMCVrmHumanoidHumanBonesHumanBoneSchemaJson `json:"upperChest,omitempty"`
}

// Correspondence between nodes and human bones
type VRMCVrmHumanoidSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// HumanBones corresponds to the JSON schema field "humanBones".
	HumanBones VRMCVrmHumanoidHumanBonesSchemaJson `json:"humanBones"`
}

// Horizontal inward movement. The left eye moves right. The right eye moves left.
type VRMCVrmLookAtRangeMapSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// Yaw and pitch angles  ( degrees )  between the head bone forward vector and the
	// eye gaze LookAt vector
	InputMaxValue *float64 `json:"inputMaxValue,omitempty"`

	// Degree for type.bone, Weight for type.expressions
	OutputScale *float64 `json:"outputScale,omitempty"`
}

// Eye gaze control
type VRMCVrmLookAtSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// The origin of LookAt. Position offset from the head bone
	OffsetFromHeadBone []float64 `json:"offsetFromHeadBone,omitempty"`

	// Horizontal inward movement. The left eye moves right. The right eye moves left.
	RangeMapHorizontalInner *VRMCVrmLookAtRangeMapSchemaJson `json:"rangeMapHorizontalInner,omitempty"`

	// Horizontal outward movement. The left eye moves left. The right eye moves
	// right.
	RangeMapHorizontalOuter *VRMCVrmLookAtRangeMapSchemaJson `json:"rangeMapHorizontalOuter,omitempty"`

	// Vertical downward movement. Both eyes move upwards
	RangeMapVerticalDown *VRMCVrmLookAtRangeMapSchemaJson `json:"rangeMapVerticalDown,omitempty"`

	// Vertical upward movement. Both eyes move downwards
	RangeMapVerticalUp *VRMCVrmLookAtRangeMapSchemaJson `json:"rangeMapVerticalUp,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *VRMCVrmLookAtSchemaJsonType `json:"type,omitempty"`
}

type VRMCVrmLookAtSchemaJsonType string

const VRMCVrmLookAtSchemaJsonTypeBone VRMCVrmLookAtSchemaJsonType = "bone"
const VRMCVrmLookAtSchemaJsonTypeExpression VRMCVrmLookAtSchemaJsonType = "expression"

type VRMCVrmMetaSchemaJson struct {
	// A flag that permits to use this model in contents contain anti-social
	// activities or hate speeches
	AllowAntisocialOrHateUsage bool `json:"allowAntisocialOrHateUsage,omitempty"`

	// A flag that permits to use this model in excessively sexual contents
	AllowExcessivelySexualUsage bool `json:"allowExcessivelySexualUsage,omitempty"`

	// A flag that permits to use this model in excessively violent contents
	AllowExcessivelyViolentUsage bool `json:"allowExcessivelyViolentUsage,omitempty"`

	// A flag that permits to use this model in political or religious contents
	AllowPoliticalOrReligiousUsage bool `json:"allowPoliticalOrReligiousUsage,omitempty"`

	// A flag that permits to redistribute this model
	AllowRedistribution bool `json:"allowRedistribution,omitempty"`

	// Authors of the model
	Authors []string `json:"authors"`

	// A person who can perform as an avatar with this model
	AvatarPermission VRMCVrmMetaSchemaJsonAvatarPermission `json:"avatarPermission,omitempty"`

	// An option that permits to use this model in commercial products
	CommercialUsage VRMCVrmMetaSchemaJsonCommercialUsage `json:"commercialUsage,omitempty"`

	// An information that describes the contact information of the author
	ContactInformation *string `json:"contactInformation,omitempty"`

	// An information that describes the copyright of the model
	CopyrightInformation *string `json:"copyrightInformation,omitempty"`

	// An option that forces or abandons to display the credit of this model
	CreditNotation VRMCVrmMetaSchemaJsonCreditNotation `json:"creditNotation,omitempty"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// A URL towards the license document this model refers to
	LicenseUrl string `json:"licenseUrl"`

	// An option that controls the condition to modify this model
	Modification VRMCVrmMetaSchemaJsonModification `json:"modification,omitempty"`

	// The name of the model
	Name string `json:"name"`

	// Describe the URL links of other license
	OtherLicenseUrl *string `json:"otherLicenseUrl,omitempty"`

	// References / original works of the model
	References []string `json:"references,omitempty"`

	// Third party licenses of the model, if required. You can use line breaks
	ThirdPartyLicenses *string `json:"thirdPartyLicenses,omitempty"`

	// The index to the thumbnail image of the model in gltf.images
	ThumbnailImage interface{} `json:"thumbnailImage,omitempty"`

	// The version of the model
	Version *string `json:"version,omitempty"`
}

type VRMCVrmMetaSchemaJsonAvatarPermission string

const VRMCVrmMetaSchemaJsonAvatarPermissionEveryone VRMCVrmMetaSchemaJsonAvatarPermission = "everyone"
const VRMCVrmMetaSchemaJsonAvatarPermissionOnlyAuthor VRMCVrmMetaSchemaJsonAvatarPermission = "onlyAuthor"
const VRMCVrmMetaSchemaJsonAvatarPermissionOnlySeparatelyLicensedPerson VRMCVrmMetaSchemaJsonAvatarPermission = "onlySeparatelyLicensedPerson"

type VRMCVrmMetaSchemaJsonCommercialUsage string

const VRMCVrmMetaSchemaJsonCommercialUsageCorporation VRMCVrmMetaSchemaJsonCommercialUsage = "corporation"
const VRMCVrmMetaSchemaJsonCommercialUsagePersonalNonProfit VRMCVrmMetaSchemaJsonCommercialUsage = "personalNonProfit"
const VRMCVrmMetaSchemaJsonCommercialUsagePersonalProfit VRMCVrmMetaSchemaJsonCommercialUsage = "personalProfit"

type VRMCVrmMetaSchemaJsonCreditNotation string

const VRMCVrmMetaSchemaJsonCreditNotationRequired VRMCVrmMetaSchemaJsonCreditNotation = "required"
const VRMCVrmMetaSchemaJsonCreditNotationUnnecessary VRMCVrmMetaSchemaJsonCreditNotation = "unnecessary"

type VRMCVrmMetaSchemaJsonModification string

const VRMCVrmMetaSchemaJsonModificationAllowModification VRMCVrmMetaSchemaJsonModification = "allowModification"
const VRMCVrmMetaSchemaJsonModificationAllowModificationRedistribution VRMCVrmMetaSchemaJsonModification = "allowModificationRedistribution"
const VRMCVrmMetaSchemaJsonModificationProhibited VRMCVrmMetaSchemaJsonModification = "prohibited"

type VRMCVrmSchemaJson struct {
	// Expressions corresponds to the JSON schema field "expressions".
	Expressions *VRMCVrmExpressionsSchemaJson `json:"expressions,omitempty"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// First-person perspective settings
	FirstPerson *VRMCVrmFirstPersonSchemaJson `json:"firstPerson,omitempty"`

	// Humanoid corresponds to the JSON schema field "humanoid".
	Humanoid VRMCVrmHumanoidSchemaJson `json:"humanoid"`

	// Eye gaze control
	LookAt *VRMCVrmLookAtSchemaJson `json:"lookAt,omitempty"`

	// Meta informations of the VRM model
	Meta VRMCVrmMetaSchemaJson `json:"meta"`

	// Specification version of VRMC_vrm
	SpecVersion string `json:"specVersion"`
}

var enumValues_VRMCVrmExpressionsExpressionMaterialColorBindSchemaJsonType = []interface{}{
	"color",
	"emissionColor",
	"shadeColor",
	"matcapColor",
	"rimColor",
	"outlineColor",
}
var enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideBlink = []interface{}{
	"none",
	"block",
	"blend",
}
var enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideLookAt = []interface{}{
	"none",
	"block",
	"blend",
}
var enumValues_VRMCVrmExpressionsExpressionSchemaJsonOverrideMouth = []interface{}{
	"none",
	"block",
	"blend",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCVrmSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["humanoid"]; !ok || v == nil {
		return fmt.Errorf("field humanoid: required")
	}
	if v, ok := raw["meta"]; !ok || v == nil {
		return fmt.Errorf("field meta: required")
	}
	if v, ok := raw["specVersion"]; !ok || v == nil {
		return fmt.Errorf("field specVersion: required")
	}
	type Plain VRMCVrmSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCVrmSchemaJson(plain)
	return nil
}

var enumValues_VRMCVrmFirstPersonMeshAnnotationSchemaJsonType = []interface{}{
	"auto",
	"both",
	"thirdPersonOnly",
	"firstPersonOnly",
}
var enumValues_VRMCVrmLookAtSchemaJsonType = []interface{}{
	"bone",
	"expression",
}
var enumValues_VRMCVrmMetaSchemaJsonAvatarPermission = []interface{}{
	"onlyAuthor",
	"onlySeparatelyLicensedPerson",
	"everyone",
}
var enumValues_VRMCVrmMetaSchemaJsonCommercialUsage = []interface{}{
	"personalNonProfit",
	"personalProfit",
	"corporation",
}
var enumValues_VRMCVrmMetaSchemaJsonCreditNotation = []interface{}{
	"required",
	"unnecessary",
}
var enumValues_VRMCVrmMetaSchemaJsonModification = []interface{}{
	"prohibited",
	"allowModification",
	"allowModificationRedistribution",
}
