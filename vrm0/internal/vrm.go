// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package internal

import "fmt"
import "reflect"
import "encoding/json"

type VrmBlendshapeBindSchemaJson struct {
	// Index corresponds to the JSON schema field "index".
	Index *int `json:"index,omitempty"`

	// Mesh corresponds to the JSON schema field "mesh".
	Mesh *int `json:"mesh,omitempty"`

	// SkinnedMeshRenderer.SetBlendShapeWeight
	Weight *float64 `json:"weight,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmMetaSchemaJsonAllowedUserName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmMetaSchemaJsonAllowedUserName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmMetaSchemaJsonAllowedUserName, v)
	}
	*j = VrmMetaSchemaJsonAllowedUserName(v)
	return nil
}

type VrmBlendshapeGroupSchemaJsonPresetName string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmMetaSchemaJsonViolentUssageName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmMetaSchemaJsonViolentUssageName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmMetaSchemaJsonViolentUssageName, v)
	}
	*j = VrmMetaSchemaJsonViolentUssageName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmBlendshapeGroupSchemaJsonPresetName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmBlendshapeGroupSchemaJsonPresetName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmBlendshapeGroupSchemaJsonPresetName, v)
	}
	*j = VrmBlendshapeGroupSchemaJsonPresetName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmMetaSchemaJsonCommercialUssageName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmMetaSchemaJsonCommercialUssageName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmMetaSchemaJsonCommercialUssageName, v)
	}
	*j = VrmMetaSchemaJsonCommercialUssageName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmHumanoidBoneSchemaJsonBone) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmHumanoidBoneSchemaJsonBone {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmHumanoidBoneSchemaJsonBone, v)
	}
	*j = VrmHumanoidBoneSchemaJsonBone(v)
	return nil
}

const VrmBlendshapeGroupSchemaJsonPresetNameA VrmBlendshapeGroupSchemaJsonPresetName = "a"

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmMetaSchemaJsonLicenseName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmMetaSchemaJsonLicenseName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmMetaSchemaJsonLicenseName, v)
	}
	*j = VrmMetaSchemaJsonLicenseName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmFirstpersonSchemaJsonLookAtTypeName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmFirstpersonSchemaJsonLookAtTypeName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmFirstpersonSchemaJsonLookAtTypeName, v)
	}
	*j = VrmFirstpersonSchemaJsonLookAtTypeName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrmMetaSchemaJsonSexualUssageName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrmMetaSchemaJsonSexualUssageName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrmMetaSchemaJsonSexualUssageName, v)
	}
	*j = VrmMetaSchemaJsonSexualUssageName(v)
	return nil
}

type VrmBlendshapeGroupSchemaJson struct {
	// Low level blendshape references.
	Binds []VrmBlendshapeBindSchemaJson `json:"binds,omitempty"`

	// 0 or 1. Do not allow an intermediate value. Value should rounded
	IsBinary *bool `json:"isBinary,omitempty"`

	// Material animation references.
	MaterialValues []VrmBlendshapeMaterialbindSchemaJson `json:"materialValues,omitempty"`

	// Expression name
	Name *string `json:"name,omitempty"`

	// Predefined Expression name
	PresetName *VrmBlendshapeGroupSchemaJsonPresetName `json:"presetName,omitempty"`
}

const VrmBlendshapeGroupSchemaJsonPresetNameAngry VrmBlendshapeGroupSchemaJsonPresetName = "angry"
const VrmBlendshapeGroupSchemaJsonPresetNameBlink VrmBlendshapeGroupSchemaJsonPresetName = "blink"
const VrmBlendshapeGroupSchemaJsonPresetNameBlinkL VrmBlendshapeGroupSchemaJsonPresetName = "blink_l"
const VrmBlendshapeGroupSchemaJsonPresetNameBlinkR VrmBlendshapeGroupSchemaJsonPresetName = "blink_r"
const VrmBlendshapeGroupSchemaJsonPresetNameE VrmBlendshapeGroupSchemaJsonPresetName = "e"
const VrmBlendshapeGroupSchemaJsonPresetNameFun VrmBlendshapeGroupSchemaJsonPresetName = "fun"
const VrmBlendshapeGroupSchemaJsonPresetNameI VrmBlendshapeGroupSchemaJsonPresetName = "i"
const VrmBlendshapeGroupSchemaJsonPresetNameJoy VrmBlendshapeGroupSchemaJsonPresetName = "joy"
const VrmBlendshapeGroupSchemaJsonPresetNameLookdown VrmBlendshapeGroupSchemaJsonPresetName = "lookdown"
const VrmBlendshapeGroupSchemaJsonPresetNameLookleft VrmBlendshapeGroupSchemaJsonPresetName = "lookleft"
const VrmBlendshapeGroupSchemaJsonPresetNameLookright VrmBlendshapeGroupSchemaJsonPresetName = "lookright"
const VrmBlendshapeGroupSchemaJsonPresetNameLookup VrmBlendshapeGroupSchemaJsonPresetName = "lookup"
const VrmBlendshapeGroupSchemaJsonPresetNameNeutral VrmBlendshapeGroupSchemaJsonPresetName = "neutral"
const VrmBlendshapeGroupSchemaJsonPresetNameO VrmBlendshapeGroupSchemaJsonPresetName = "o"
const VrmBlendshapeGroupSchemaJsonPresetNameSorrow VrmBlendshapeGroupSchemaJsonPresetName = "sorrow"
const VrmBlendshapeGroupSchemaJsonPresetNameU VrmBlendshapeGroupSchemaJsonPresetName = "u"
const VrmBlendshapeGroupSchemaJsonPresetNameUnknown VrmBlendshapeGroupSchemaJsonPresetName = "unknown"

type VrmBlendshapeMaterialbindSchemaJson struct {
	// MaterialName corresponds to the JSON schema field "materialName".
	MaterialName *string `json:"materialName,omitempty"`

	// PropertyName corresponds to the JSON schema field "propertyName".
	PropertyName *string `json:"propertyName,omitempty"`

	// TargetValue corresponds to the JSON schema field "targetValue".
	TargetValue []float64 `json:"targetValue,omitempty"`
}

// BlendShapeAvatar of UniVRM
type VrmBlendshapeSchemaJson struct {
	// BlendShapeGroups corresponds to the JSON schema field "blendShapeGroups".
	BlendShapeGroups []VrmBlendshapeGroupSchemaJson `json:"blendShapeGroups,omitempty"`
}

// Eye controller setting.
type VrmFirstpersonDegreemapSchemaJson struct {
	// None linear mapping params. time, value, inTangent, outTangent
	Curve []float64 `json:"curve,omitempty"`

	// Look at input clamp range degree.
	XRange *float64 `json:"xRange,omitempty"`

	// Look at map range degree from xRange.
	YRange *float64 `json:"yRange,omitempty"`
}

type VrmFirstpersonMeshannotationSchemaJson struct {
	// FirstPersonFlag corresponds to the JSON schema field "firstPersonFlag".
	FirstPersonFlag *string `json:"firstPersonFlag,omitempty"`

	// Mesh corresponds to the JSON schema field "mesh".
	Mesh *int `json:"mesh,omitempty"`
}

type VrmFirstpersonSchemaJson struct {
	// The bone whose rendering should be turned off in first-person view. Usually
	// Head is specified.
	FirstPersonBone *int `json:"firstPersonBone,omitempty"`

	// The target position of the VR headset in first-person view. It is assumed that
	// an offset from the head bone to the VR headset is added.
	FirstPersonBoneOffset *VrmFirstpersonSchemaJsonFirstPersonBoneOffset `json:"firstPersonBoneOffset,omitempty"`

	// LookAtHorizontalInner corresponds to the JSON schema field
	// "lookAtHorizontalInner".
	LookAtHorizontalInner *VrmFirstpersonDegreemapSchemaJson `json:"lookAtHorizontalInner,omitempty"`

	// LookAtHorizontalOuter corresponds to the JSON schema field
	// "lookAtHorizontalOuter".
	LookAtHorizontalOuter *VrmFirstpersonDegreemapSchemaJson `json:"lookAtHorizontalOuter,omitempty"`

	// Eye controller mode.
	LookAtTypeName *VrmFirstpersonSchemaJsonLookAtTypeName `json:"lookAtTypeName,omitempty"`

	// LookAtVerticalDown corresponds to the JSON schema field "lookAtVerticalDown".
	LookAtVerticalDown *VrmFirstpersonDegreemapSchemaJson `json:"lookAtVerticalDown,omitempty"`

	// LookAtVerticalUp corresponds to the JSON schema field "lookAtVerticalUp".
	LookAtVerticalUp *VrmFirstpersonDegreemapSchemaJson `json:"lookAtVerticalUp,omitempty"`

	// Switch display / undisplay for each mesh in first-person view or the others.
	MeshAnnotations []VrmFirstpersonMeshannotationSchemaJson `json:"meshAnnotations,omitempty"`
}

// The target position of the VR headset in first-person view. It is assumed that
// an offset from the head bone to the VR headset is added.
type VrmFirstpersonSchemaJsonFirstPersonBoneOffset struct {
	// X corresponds to the JSON schema field "x".
	X *float64 `json:"x,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y *float64 `json:"y,omitempty"`

	// Z corresponds to the JSON schema field "z".
	Z *float64 `json:"z,omitempty"`
}

type VrmFirstpersonSchemaJsonLookAtTypeName string

const VrmFirstpersonSchemaJsonLookAtTypeNameBlendShape VrmFirstpersonSchemaJsonLookAtTypeName = "BlendShape"
const VrmFirstpersonSchemaJsonLookAtTypeNameBone VrmFirstpersonSchemaJsonLookAtTypeName = "Bone"

type VrmHumanoidBoneSchemaJson struct {
	// Unity's HumanLimit.axisLength
	AxisLength *float64 `json:"axisLength,omitempty"`

	// Human bone name.
	Bone *VrmHumanoidBoneSchemaJsonBone `json:"bone,omitempty"`

	// Unity's HumanLimit.center
	Center *VrmHumanoidBoneSchemaJsonCenter `json:"center,omitempty"`

	// Unity's HumanLimit.max
	Max *VrmHumanoidBoneSchemaJsonMax `json:"max,omitempty"`

	// Unity's HumanLimit.min
	Min *VrmHumanoidBoneSchemaJsonMin `json:"min,omitempty"`

	// Reference node index
	Node *int `json:"node,omitempty"`

	// Unity's HumanLimit.useDefaultValues
	UseDefaultValues *bool `json:"useDefaultValues,omitempty"`
}

type VrmHumanoidBoneSchemaJsonBone string

const VrmHumanoidBoneSchemaJsonBoneChest VrmHumanoidBoneSchemaJsonBone = "chest"
const VrmHumanoidBoneSchemaJsonBoneHead VrmHumanoidBoneSchemaJsonBone = "head"
const VrmHumanoidBoneSchemaJsonBoneHips VrmHumanoidBoneSchemaJsonBone = "hips"
const VrmHumanoidBoneSchemaJsonBoneJaw VrmHumanoidBoneSchemaJsonBone = "jaw"
const VrmHumanoidBoneSchemaJsonBoneLeftEye VrmHumanoidBoneSchemaJsonBone = "leftEye"
const VrmHumanoidBoneSchemaJsonBoneLeftFoot VrmHumanoidBoneSchemaJsonBone = "leftFoot"
const VrmHumanoidBoneSchemaJsonBoneLeftHand VrmHumanoidBoneSchemaJsonBone = "leftHand"
const VrmHumanoidBoneSchemaJsonBoneLeftIndexDistal VrmHumanoidBoneSchemaJsonBone = "leftIndexDistal"
const VrmHumanoidBoneSchemaJsonBoneLeftIndexIntermediate VrmHumanoidBoneSchemaJsonBone = "leftIndexIntermediate"
const VrmHumanoidBoneSchemaJsonBoneLeftIndexProximal VrmHumanoidBoneSchemaJsonBone = "leftIndexProximal"
const VrmHumanoidBoneSchemaJsonBoneLeftLittleDistal VrmHumanoidBoneSchemaJsonBone = "leftLittleDistal"
const VrmHumanoidBoneSchemaJsonBoneLeftLittleIntermediate VrmHumanoidBoneSchemaJsonBone = "leftLittleIntermediate"
const VrmHumanoidBoneSchemaJsonBoneLeftLittleProximal VrmHumanoidBoneSchemaJsonBone = "leftLittleProximal"
const VrmHumanoidBoneSchemaJsonBoneLeftLowerArm VrmHumanoidBoneSchemaJsonBone = "leftLowerArm"
const VrmHumanoidBoneSchemaJsonBoneLeftLowerLeg VrmHumanoidBoneSchemaJsonBone = "leftLowerLeg"
const VrmHumanoidBoneSchemaJsonBoneLeftMiddleDistal VrmHumanoidBoneSchemaJsonBone = "leftMiddleDistal"
const VrmHumanoidBoneSchemaJsonBoneLeftMiddleIntermediate VrmHumanoidBoneSchemaJsonBone = "leftMiddleIntermediate"
const VrmHumanoidBoneSchemaJsonBoneLeftMiddleProximal VrmHumanoidBoneSchemaJsonBone = "leftMiddleProximal"
const VrmHumanoidBoneSchemaJsonBoneLeftRingDistal VrmHumanoidBoneSchemaJsonBone = "leftRingDistal"
const VrmHumanoidBoneSchemaJsonBoneLeftRingIntermediate VrmHumanoidBoneSchemaJsonBone = "leftRingIntermediate"
const VrmHumanoidBoneSchemaJsonBoneLeftRingProximal VrmHumanoidBoneSchemaJsonBone = "leftRingProximal"
const VrmHumanoidBoneSchemaJsonBoneLeftShoulder VrmHumanoidBoneSchemaJsonBone = "leftShoulder"
const VrmHumanoidBoneSchemaJsonBoneLeftThumbDistal VrmHumanoidBoneSchemaJsonBone = "leftThumbDistal"
const VrmHumanoidBoneSchemaJsonBoneLeftThumbIntermediate VrmHumanoidBoneSchemaJsonBone = "leftThumbIntermediate"
const VrmHumanoidBoneSchemaJsonBoneLeftThumbProximal VrmHumanoidBoneSchemaJsonBone = "leftThumbProximal"
const VrmHumanoidBoneSchemaJsonBoneLeftToes VrmHumanoidBoneSchemaJsonBone = "leftToes"
const VrmHumanoidBoneSchemaJsonBoneLeftUpperArm VrmHumanoidBoneSchemaJsonBone = "leftUpperArm"
const VrmHumanoidBoneSchemaJsonBoneLeftUpperLeg VrmHumanoidBoneSchemaJsonBone = "leftUpperLeg"
const VrmHumanoidBoneSchemaJsonBoneNeck VrmHumanoidBoneSchemaJsonBone = "neck"
const VrmHumanoidBoneSchemaJsonBoneRightEye VrmHumanoidBoneSchemaJsonBone = "rightEye"
const VrmHumanoidBoneSchemaJsonBoneRightFoot VrmHumanoidBoneSchemaJsonBone = "rightFoot"
const VrmHumanoidBoneSchemaJsonBoneRightHand VrmHumanoidBoneSchemaJsonBone = "rightHand"
const VrmHumanoidBoneSchemaJsonBoneRightIndexDistal VrmHumanoidBoneSchemaJsonBone = "rightIndexDistal"
const VrmHumanoidBoneSchemaJsonBoneRightIndexIntermediate VrmHumanoidBoneSchemaJsonBone = "rightIndexIntermediate"
const VrmHumanoidBoneSchemaJsonBoneRightIndexProximal VrmHumanoidBoneSchemaJsonBone = "rightIndexProximal"
const VrmHumanoidBoneSchemaJsonBoneRightLittleDistal VrmHumanoidBoneSchemaJsonBone = "rightLittleDistal"
const VrmHumanoidBoneSchemaJsonBoneRightLittleIntermediate VrmHumanoidBoneSchemaJsonBone = "rightLittleIntermediate"
const VrmHumanoidBoneSchemaJsonBoneRightLittleProximal VrmHumanoidBoneSchemaJsonBone = "rightLittleProximal"
const VrmHumanoidBoneSchemaJsonBoneRightLowerArm VrmHumanoidBoneSchemaJsonBone = "rightLowerArm"
const VrmHumanoidBoneSchemaJsonBoneRightLowerLeg VrmHumanoidBoneSchemaJsonBone = "rightLowerLeg"
const VrmHumanoidBoneSchemaJsonBoneRightMiddleDistal VrmHumanoidBoneSchemaJsonBone = "rightMiddleDistal"
const VrmHumanoidBoneSchemaJsonBoneRightMiddleIntermediate VrmHumanoidBoneSchemaJsonBone = "rightMiddleIntermediate"
const VrmHumanoidBoneSchemaJsonBoneRightMiddleProximal VrmHumanoidBoneSchemaJsonBone = "rightMiddleProximal"
const VrmHumanoidBoneSchemaJsonBoneRightRingDistal VrmHumanoidBoneSchemaJsonBone = "rightRingDistal"
const VrmHumanoidBoneSchemaJsonBoneRightRingIntermediate VrmHumanoidBoneSchemaJsonBone = "rightRingIntermediate"
const VrmHumanoidBoneSchemaJsonBoneRightRingProximal VrmHumanoidBoneSchemaJsonBone = "rightRingProximal"
const VrmHumanoidBoneSchemaJsonBoneRightShoulder VrmHumanoidBoneSchemaJsonBone = "rightShoulder"
const VrmHumanoidBoneSchemaJsonBoneRightThumbDistal VrmHumanoidBoneSchemaJsonBone = "rightThumbDistal"
const VrmHumanoidBoneSchemaJsonBoneRightThumbIntermediate VrmHumanoidBoneSchemaJsonBone = "rightThumbIntermediate"
const VrmHumanoidBoneSchemaJsonBoneRightThumbProximal VrmHumanoidBoneSchemaJsonBone = "rightThumbProximal"
const VrmHumanoidBoneSchemaJsonBoneRightToes VrmHumanoidBoneSchemaJsonBone = "rightToes"
const VrmHumanoidBoneSchemaJsonBoneRightUpperArm VrmHumanoidBoneSchemaJsonBone = "rightUpperArm"
const VrmHumanoidBoneSchemaJsonBoneRightUpperLeg VrmHumanoidBoneSchemaJsonBone = "rightUpperLeg"
const VrmHumanoidBoneSchemaJsonBoneSpine VrmHumanoidBoneSchemaJsonBone = "spine"
const VrmHumanoidBoneSchemaJsonBoneUpperChest VrmHumanoidBoneSchemaJsonBone = "upperChest"

// Unity's HumanLimit.center
type VrmHumanoidBoneSchemaJsonCenter struct {
	// X corresponds to the JSON schema field "x".
	X *float64 `json:"x,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y *float64 `json:"y,omitempty"`

	// Z corresponds to the JSON schema field "z".
	Z *float64 `json:"z,omitempty"`
}

// Unity's HumanLimit.max
type VrmHumanoidBoneSchemaJsonMax struct {
	// X corresponds to the JSON schema field "x".
	X *float64 `json:"x,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y *float64 `json:"y,omitempty"`

	// Z corresponds to the JSON schema field "z".
	Z *float64 `json:"z,omitempty"`
}

// Unity's HumanLimit.min
type VrmHumanoidBoneSchemaJsonMin struct {
	// X corresponds to the JSON schema field "x".
	X *float64 `json:"x,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y *float64 `json:"y,omitempty"`

	// Z corresponds to the JSON schema field "z".
	Z *float64 `json:"z,omitempty"`
}

type VrmHumanoidSchemaJson struct {
	// Unity's HumanDescription.armStretch
	ArmStretch *float64 `json:"armStretch,omitempty"`

	// Unity's HumanDescription.feetSpacing
	FeetSpacing *float64 `json:"feetSpacing,omitempty"`

	// Unity's HumanDescription.hasTranslationDoF
	HasTranslationDoF *bool `json:"hasTranslationDoF,omitempty"`

	// HumanBones corresponds to the JSON schema field "humanBones".
	HumanBones []VrmHumanoidBoneSchemaJson `json:"humanBones,omitempty"`

	// Unity's HumanDescription.legStretch
	LegStretch *float64 `json:"legStretch,omitempty"`

	// Unity's HumanDescription.lowerArmTwist
	LowerArmTwist *float64 `json:"lowerArmTwist,omitempty"`

	// Unity's HumanDescription.lowerLegTwist
	LowerLegTwist *float64 `json:"lowerLegTwist,omitempty"`

	// Unity's HumanDescription.upperArmTwist
	UpperArmTwist *float64 `json:"upperArmTwist,omitempty"`

	// Unity's HumanDescription.upperLegTwist
	UpperLegTwist *float64 `json:"upperLegTwist,omitempty"`
}

type VrmMaterialSchemaJson struct {
	// FloatProperties corresponds to the JSON schema field "floatProperties".
	FloatProperties VrmMaterialSchemaJsonFloatProperties `json:"floatProperties,omitempty"`

	// KeywordMap corresponds to the JSON schema field "keywordMap".
	KeywordMap VrmMaterialSchemaJsonKeywordMap `json:"keywordMap,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// RenderQueue corresponds to the JSON schema field "renderQueue".
	RenderQueue *int `json:"renderQueue,omitempty"`

	// This contains shader name.  VRM/MToon, VRM/UnlitTransparentZWrite, and
	// VRM_USE_GLTFSHADER (and legacy materials as Standard, UniGLTF/UniUnlit,
	// VRM/UnlitTexture, VRM/UnlitCutout, VRM/UnlitTransparent) . If
	// VRM_USE_GLTFSHADER is specified, use same index of gltf's material settings
	Shader *string `json:"shader,omitempty"`

	// TagMap corresponds to the JSON schema field "tagMap".
	TagMap VrmMaterialSchemaJsonTagMap `json:"tagMap,omitempty"`

	// TextureProperties corresponds to the JSON schema field "textureProperties".
	TextureProperties VrmMaterialSchemaJsonTextureProperties `json:"textureProperties,omitempty"`

	// VectorProperties corresponds to the JSON schema field "vectorProperties".
	VectorProperties VrmMaterialSchemaJsonVectorProperties `json:"vectorProperties,omitempty"`
}

type VrmMaterialSchemaJsonFloatProperties map[string]float64

type VrmMaterialSchemaJsonKeywordMap map[string]bool

type VrmMaterialSchemaJsonTagMap map[string]string

type VrmMaterialSchemaJsonTextureProperties map[string]int

type VrmMaterialSchemaJsonVectorProperties map[string][]float64

type VrmMetaSchemaJson struct {
	// A person who can perform with this avatar
	AllowedUserName *VrmMetaSchemaJsonAllowedUserName `json:"allowedUserName,omitempty"`

	// Author of VRM model
	Author *string `json:"author,omitempty"`

	// For commercial use
	CommercialUssageName *VrmMetaSchemaJsonCommercialUssageName `json:"commercialUssageName,omitempty"`

	// Contact Information of VRM model author
	ContactInformation *string `json:"contactInformation,omitempty"`

	// License type
	LicenseName *VrmMetaSchemaJsonLicenseName `json:"licenseName,omitempty"`

	// If “Other” is selected, put the URL link of the license document here.
	OtherLicenseUrl *string `json:"otherLicenseUrl,omitempty"`

	// If there are any conditions not mentioned above, put the URL link of the
	// license document here.
	OtherPermissionUrl *string `json:"otherPermissionUrl,omitempty"`

	// Reference of VRM model
	Reference *string `json:"reference,omitempty"`

	// Permission to perform sexual acts with this avatar
	SexualUssageName *VrmMetaSchemaJsonSexualUssageName `json:"sexualUssageName,omitempty"`

	// Thumbnail of VRM model
	Texture *int `json:"texture,omitempty"`

	// Title of VRM model
	Title *string `json:"title,omitempty"`

	// Version of VRM model
	Version *string `json:"version,omitempty"`

	// Permission to perform violent acts with this avatar
	ViolentUssageName *VrmMetaSchemaJsonViolentUssageName `json:"violentUssageName,omitempty"`
}

type VrmMetaSchemaJsonAllowedUserName string

const VrmMetaSchemaJsonAllowedUserNameEveryone VrmMetaSchemaJsonAllowedUserName = "Everyone"
const VrmMetaSchemaJsonAllowedUserNameExplicitlyLicensedPerson VrmMetaSchemaJsonAllowedUserName = "ExplicitlyLicensedPerson"
const VrmMetaSchemaJsonAllowedUserNameOnlyAuthor VrmMetaSchemaJsonAllowedUserName = "OnlyAuthor"

type VrmMetaSchemaJsonCommercialUssageName string

const VrmMetaSchemaJsonCommercialUssageNameAllow VrmMetaSchemaJsonCommercialUssageName = "Allow"
const VrmMetaSchemaJsonCommercialUssageNameDisallow VrmMetaSchemaJsonCommercialUssageName = "Disallow"

type VrmMetaSchemaJsonLicenseName string

const VrmMetaSchemaJsonLicenseNameCC0 VrmMetaSchemaJsonLicenseName = "CC0"
const VrmMetaSchemaJsonLicenseNameCCBY VrmMetaSchemaJsonLicenseName = "CC_BY"
const VrmMetaSchemaJsonLicenseNameCCBYNC VrmMetaSchemaJsonLicenseName = "CC_BY_NC"
const VrmMetaSchemaJsonLicenseNameCCBYNCND VrmMetaSchemaJsonLicenseName = "CC_BY_NC_ND"
const VrmMetaSchemaJsonLicenseNameCCBYNCSA VrmMetaSchemaJsonLicenseName = "CC_BY_NC_SA"
const VrmMetaSchemaJsonLicenseNameCCBYND VrmMetaSchemaJsonLicenseName = "CC_BY_ND"
const VrmMetaSchemaJsonLicenseNameCCBYSA VrmMetaSchemaJsonLicenseName = "CC_BY_SA"
const VrmMetaSchemaJsonLicenseNameOther VrmMetaSchemaJsonLicenseName = "Other"
const VrmMetaSchemaJsonLicenseNameRedistributionProhibited VrmMetaSchemaJsonLicenseName = "Redistribution_Prohibited"

type VrmMetaSchemaJsonSexualUssageName string

const VrmMetaSchemaJsonSexualUssageNameAllow VrmMetaSchemaJsonSexualUssageName = "Allow"
const VrmMetaSchemaJsonSexualUssageNameDisallow VrmMetaSchemaJsonSexualUssageName = "Disallow"

type VrmMetaSchemaJsonViolentUssageName string

const VrmMetaSchemaJsonViolentUssageNameAllow VrmMetaSchemaJsonViolentUssageName = "Allow"
const VrmMetaSchemaJsonViolentUssageNameDisallow VrmMetaSchemaJsonViolentUssageName = "Disallow"

// VRM extension is for 3d humanoid avatars (and models) in VR applications.
type VrmSchemaJson struct {
	// BlendShapeMaster corresponds to the JSON schema field "blendShapeMaster".
	BlendShapeMaster *VrmBlendshapeSchemaJson `json:"blendShapeMaster,omitempty"`

	// Version of exporter that vrm created. UniVRM-0.46
	ExporterVersion *string `json:"exporterVersion,omitempty"`

	// FirstPerson corresponds to the JSON schema field "firstPerson".
	FirstPerson *VrmFirstpersonSchemaJson `json:"firstPerson,omitempty"`

	// Humanoid corresponds to the JSON schema field "humanoid".
	Humanoid *VrmHumanoidSchemaJson `json:"humanoid,omitempty"`

	// MaterialProperties corresponds to the JSON schema field "materialProperties".
	MaterialProperties []VrmMaterialSchemaJson `json:"materialProperties,omitempty"`

	// Meta corresponds to the JSON schema field "meta".
	Meta *VrmMetaSchemaJson `json:"meta,omitempty"`

	// SecondaryAnimation corresponds to the JSON schema field "secondaryAnimation".
	SecondaryAnimation *VrmSecondaryanimationSchemaJson `json:"secondaryAnimation,omitempty"`

	// Version of VRM specification. 0.0
	SpecVersion *string `json:"specVersion,omitempty"`
}

type VrmSecondaryanimationCollidergroupSchemaJson struct {
	// Colliders corresponds to the JSON schema field "colliders".
	Colliders []VrmSecondaryanimationCollidergroupSchemaJsonCollidersElem `json:"colliders,omitempty"`

	// The node of the collider group for setting up collision detections.
	Node *int `json:"node,omitempty"`
}

type VrmSecondaryanimationCollidergroupSchemaJsonCollidersElem struct {
	// The local coordinate from the node of the collider group in *left-handed* Y-up
	// coordinate.
	Offset *VrmSecondaryanimationCollidergroupSchemaJsonCollidersElemOffset `json:"offset,omitempty"`

	// The radius of the collider.
	Radius *float64 `json:"radius,omitempty"`
}

// The local coordinate from the node of the collider group in *left-handed* Y-up
// coordinate.
type VrmSecondaryanimationCollidergroupSchemaJsonCollidersElemOffset struct {
	// X corresponds to the JSON schema field "x".
	X *float64 `json:"x,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y *float64 `json:"y,omitempty"`

	// Z corresponds to the JSON schema field "z".
	Z *float64 `json:"z,omitempty"`
}

// The setting of automatic animation of string-like objects such as tails and
// hairs.
type VrmSecondaryanimationSchemaJson struct {
	// BoneGroups corresponds to the JSON schema field "boneGroups".
	BoneGroups []VrmSecondaryanimationSpringSchemaJson `json:"boneGroups,omitempty"`

	// ColliderGroups corresponds to the JSON schema field "colliderGroups".
	ColliderGroups []VrmSecondaryanimationCollidergroupSchemaJson `json:"colliderGroups,omitempty"`
}

type VrmSecondaryanimationSpringSchemaJson struct {
	// Specify the node index of the root bone of the swaying object.
	Bones []int `json:"bones,omitempty"`

	// The reference point of a swaying object can be set at any location except the
	// origin. When implementing UI moving with warp, the parent node to move with
	// warp can be specified if you don't want to make the object swaying with warp
	// movement.
	Center *int `json:"center,omitempty"`

	// Specify the index of the collider group for collisions with swaying objects.
	ColliderGroups []int `json:"colliderGroups,omitempty"`

	// Annotation comment
	Comment *string `json:"comment,omitempty"`

	// The resistance (deceleration) of automatic animation.
	DragForce *float64 `json:"dragForce,omitempty"`

	// The direction of gravity. Set (0, -1, 0) for simulating the gravity. Set (1, 0,
	// 0) for simulating the wind.
	GravityDir *VrmSecondaryanimationSpringSchemaJsonGravityDir `json:"gravityDir,omitempty"`

	// The strength of gravity.
	GravityPower *float64 `json:"gravityPower,omitempty"`

	// The radius of the sphere used for the collision detection with colliders.
	HitRadius *float64 `json:"hitRadius,omitempty"`

	// The resilience of the swaying object (the power of returning to the initial
	// pose).
	Stiffiness *float64 `json:"stiffiness,omitempty"`
}

// The direction of gravity. Set (0, -1, 0) for simulating the gravity. Set (1, 0,
// 0) for simulating the wind.
type VrmSecondaryanimationSpringSchemaJsonGravityDir struct {
	// X corresponds to the JSON schema field "x".
	X *float64 `json:"x,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y *float64 `json:"y,omitempty"`

	// Z corresponds to the JSON schema field "z".
	Z *float64 `json:"z,omitempty"`
}

var enumValues_VrmBlendshapeGroupSchemaJsonPresetName = []interface{}{
	"unknown",
	"neutral",
	"a",
	"i",
	"u",
	"e",
	"o",
	"blink",
	"joy",
	"angry",
	"sorrow",
	"fun",
	"lookup",
	"lookdown",
	"lookleft",
	"lookright",
	"blink_l",
	"blink_r",
}
var enumValues_VrmFirstpersonSchemaJsonLookAtTypeName = []interface{}{
	"Bone",
	"BlendShape",
}
var enumValues_VrmHumanoidBoneSchemaJsonBone = []interface{}{
	"hips",
	"leftUpperLeg",
	"rightUpperLeg",
	"leftLowerLeg",
	"rightLowerLeg",
	"leftFoot",
	"rightFoot",
	"spine",
	"chest",
	"neck",
	"head",
	"leftShoulder",
	"rightShoulder",
	"leftUpperArm",
	"rightUpperArm",
	"leftLowerArm",
	"rightLowerArm",
	"leftHand",
	"rightHand",
	"leftToes",
	"rightToes",
	"leftEye",
	"rightEye",
	"jaw",
	"leftThumbProximal",
	"leftThumbIntermediate",
	"leftThumbDistal",
	"leftIndexProximal",
	"leftIndexIntermediate",
	"leftIndexDistal",
	"leftMiddleProximal",
	"leftMiddleIntermediate",
	"leftMiddleDistal",
	"leftRingProximal",
	"leftRingIntermediate",
	"leftRingDistal",
	"leftLittleProximal",
	"leftLittleIntermediate",
	"leftLittleDistal",
	"rightThumbProximal",
	"rightThumbIntermediate",
	"rightThumbDistal",
	"rightIndexProximal",
	"rightIndexIntermediate",
	"rightIndexDistal",
	"rightMiddleProximal",
	"rightMiddleIntermediate",
	"rightMiddleDistal",
	"rightRingProximal",
	"rightRingIntermediate",
	"rightRingDistal",
	"rightLittleProximal",
	"rightLittleIntermediate",
	"rightLittleDistal",
	"upperChest",
}
var enumValues_VrmMetaSchemaJsonAllowedUserName = []interface{}{
	"OnlyAuthor",
	"ExplicitlyLicensedPerson",
	"Everyone",
}
var enumValues_VrmMetaSchemaJsonCommercialUssageName = []interface{}{
	"Disallow",
	"Allow",
}
var enumValues_VrmMetaSchemaJsonLicenseName = []interface{}{
	"Redistribution_Prohibited",
	"CC0",
	"CC_BY",
	"CC_BY_NC",
	"CC_BY_SA",
	"CC_BY_NC_SA",
	"CC_BY_ND",
	"CC_BY_NC_ND",
	"Other",
}
var enumValues_VrmMetaSchemaJsonSexualUssageName = []interface{}{
	"Disallow",
	"Allow",
}
var enumValues_VrmMetaSchemaJsonViolentUssageName = []interface{}{
	"Disallow",
	"Allow",
}
