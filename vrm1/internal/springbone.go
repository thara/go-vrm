// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package internal

import (
	"encoding/json"
	"fmt"
)

// collider group definition for SpringBone
type VRMCSpringBoneColliderGroupSchemaJson struct {
	// An array of colliders.
	Colliders []int `json:"colliders"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// Name of the ColliderGroup
	Name *string `json:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCSpringBoneColliderGroupSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["colliders"]; !ok || v == nil {
		return fmt.Errorf("field colliders: required")
	}
	type Plain VRMCSpringBoneColliderGroupSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCSpringBoneColliderGroupSchemaJson(plain)
	return nil
}

// collider definition for SpringBone
type VRMCSpringBoneColliderSchemaJson struct {
	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// The node index.
	Node interface{} `json:"node"`

	// Shape corresponds to the JSON schema field "shape".
	Shape interface{} `json:"shape"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCSpringBoneColliderSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node: required")
	}
	if v, ok := raw["shape"]; !ok || v == nil {
		return fmt.Errorf("field shape: required")
	}
	type Plain VRMCSpringBoneColliderSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCSpringBoneColliderSchemaJson(plain)
	return nil
}

// A bone joint of VRMCSpringBone.
type VRMCSpringBoneJointSchemaJson struct {
	// Air resistance. Deceleration force.
	DragForce float64 `json:"dragForce,omitempty"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// The direction of gravity. A gravity other than downward direction also works.
	GravityDir []float64 `json:"gravityDir,omitempty"`

	// Gravitational acceleration.
	GravityPower float64 `json:"gravityPower,omitempty"`

	// The radius of spring sphere.
	HitRadius float64 `json:"hitRadius,omitempty"`

	// The node index.
	Node interface{} `json:"node"`

	// The force to return to the initial pose.
	Stiffness float64 `json:"stiffness,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCSpringBoneJointSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node: required")
	}
	type Plain VRMCSpringBoneJointSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["dragForce"]; !ok || v == nil {
		plain.DragForce = 0.5
	}
	if v, ok := raw["gravityDir"]; !ok || v == nil {
		plain.GravityDir = []float64{
			0,
			-1,
			0,
		}
	}
	if v, ok := raw["gravityPower"]; !ok || v == nil {
		plain.GravityPower = 0
	}
	if v, ok := raw["hitRadius"]; !ok || v == nil {
		plain.HitRadius = 0
	}
	if v, ok := raw["stiffness"]; !ok || v == nil {
		plain.Stiffness = 1
	}
	*j = VRMCSpringBoneJointSchemaJson(plain)
	return nil
}

// A bone group of VRMCSpringBone.
type VRMCSpringBoneSpringSchemaJson struct {
	// An index of node which is used as a root of center space.
	Center interface{} `json:"center,omitempty"`

	// Indices of ColliderGroups that detect collision with this spring.
	ColliderGroups []int `json:"colliderGroups,omitempty"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// Joints of the spring. Except for the first element, a previous joint of the
	// array must be an ancestor of the joint.
	Joints []VRMCSpringBoneJointSchemaJson `json:"joints"`

	// Name of the Spring
	Name *string `json:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCSpringBoneSpringSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["joints"]; !ok || v == nil {
		return fmt.Errorf("field joints: required")
	}
	type Plain VRMCSpringBoneSpringSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCSpringBoneSpringSchemaJson(plain)
	return nil
}

// SpringBone makes objects such as costumes and hair swaying
type VRMCSpringBoneSchemaJson struct {
	// An array of colliderGroups.
	ColliderGroups []VRMCSpringBoneColliderGroupSchemaJson `json:"colliderGroups,omitempty"`

	// An array of colliders.
	Colliders []VRMCSpringBoneColliderSchemaJson `json:"colliders,omitempty"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions interface{} `json:"extensions,omitempty"`

	// Extras corresponds to the JSON schema field "extras".
	Extras interface{} `json:"extras,omitempty"`

	// Specification version of VRMC_springBone
	SpecVersion string `json:"specVersion"`

	// An array of springs.
	Springs []VRMCSpringBoneSpringSchemaJson `json:"springs,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VRMCSpringBoneSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["specVersion"]; !ok || v == nil {
		return fmt.Errorf("field specVersion: required")
	}
	type Plain VRMCSpringBoneSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VRMCSpringBoneSchemaJson(plain)
	return nil
}
